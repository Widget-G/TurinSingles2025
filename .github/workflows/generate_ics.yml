#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
generate_ics.py ‚Äî tworzy kalendarz ICS dla Nitto ATP Finals 2025 (Turin)
Automatycznie wybiera aktualny dzie≈Ñ turnieju, ustawia strefƒô czasowƒÖ CET (Polska),
i dodaje godziny mecz√≥w w lokalnym czasie.
Fallback: sesje domy≈õlne, je≈õli brak danych JSON.
"""

import os
import requests
from datetime import datetime, timedelta
from icalendar import Calendar, Event, Alarm, vDatetime
import pytz

# === KONFIGURACJA ===
TOURNAMENT = "Nitto ATP Finals 2025 ‚Äì Singles"
LOCATION = "Turin, Italy"
TOURNAMENT_START = datetime(2025, 11, 9)
TOURNAMENT_END = datetime(2025, 11, 16)

TIMEZONE = pytz.timezone("Europe/Warsaw")  # CET/Polska

BASE_URL_TEMPLATE = "https://www.atptour.com/en/scores/current/nitto-atp-finals/605/daily-schedule?day={day}"
POSSIBLE_JSON_URLS_TEMPLATE = [
    "https://www.atptour.com/-/media/json/scores/2025/605/schedule.json",
    "https://www.atptour.com/en/-/media/json/scores/current/605/schedule.json",
    "https://www.atptour.com/en/-/media/json/scores/current/nitto-atp-finals/schedule.json",
]

# === ≈öCIE≈ªKI ===
base_dir = os.path.dirname(__file__)
output_dir = os.path.join(base_dir, "output")
os.makedirs(output_dir, exist_ok=True)
ics_path = os.path.join(output_dir, "ATP_Finals_2025_Singles_Turin.ics")


# === Funkcja: oblicza dzie≈Ñ turnieju na podstawie dzisiejszej daty ===
def get_current_day():
    today = datetime.now(TIMEZONE)
    if TOURNAMENT_START <= today <= TOURNAMENT_END:
        day_number = (today - TOURNAMENT_START).days + 1
        print(f"üìÖ Dzisiaj jest dzie≈Ñ {day_number} turnieju.")
        return day_number
    print("‚ö†Ô∏è Dzisiejsza data poza dniami turnieju. U≈ºywam dnia 1 jako domy≈õlnego.")
    return 1


# === Funkcja: pobiera mecze z JSON (je≈õli istnieje) ===
def get_matches_from_json():
    for url in POSSIBLE_JSON_URLS_TEMPLATE:
        print(f"üîç Pr√≥ba pobrania JSON: {url}")
        try:
            r = requests.get(url, timeout=10)
            if r.status_code == 200 and "application/json" in r.headers.get("Content-Type", ""):
                data = r.json()
                matches = []

                for day in data.get("Days", []):
                    for match in day.get("Matches", []):
                        p1 = match.get("Player1", {}).get("Name") or "TBD"
                        p2 = match.get("Player2", {}).get("Name") or "TBD"
                        time_text = match.get("StartTime") or day.get("Day")
                        matches.append((p1, p2, time_text))
                if matches:
                    print(f"‚úÖ Znaleziono {len(matches)} mecz√≥w w JSON.")
                    return matches
        except Exception as e:
            print(f"‚ö†Ô∏è Nie uda≈Ço siƒô pobraƒá z {url}: {e}")
    print("‚ùå Nie znaleziono poprawnego JSON-a z danymi.")
    return []


# === Funkcja: tworzy kalendarz ICS z CET ===
def create_ics(matches):
    cal = Calendar()
    cal.add("prodid", "-//ATP Finals 2025//kgforce//")
    cal.add("version", "2.0")

    if not matches:
        print("‚öôÔ∏è Tworzenie kalendarza z domy≈õlnymi sesjami (fallback).")
        for i, (session_type, hour) in enumerate([
            ("Day Session", 13),
            ("Evening Session", 21),
        ] * ((TOURNAMENT_END - TOURNAMENT_START).days + 1)):
            event_date = TOURNAMENT_START + timedelta(days=i // 2)
            start = TIMEZONE.localize(event_date.replace(hour=hour, minute=0))
            end = start + timedelta(hours=3)

            ev = Event()
            ev.add("summary", f"ATP Finals 2025 Singles ‚Äì {session_type} (Turin)")
            ev.add("description", "Group Stage ‚Äì ATP schedule pending")
            ev.add("location", LOCATION)
            ev.add("dtstart", vDatetime(start))
            ev.add("dtend", vDatetime(end))
            ev.add("dtstamp", vDatetime(datetime.now(TIMEZONE)))
            ev.add("uid", f"default-session-{i}@atpfinals2025")

            alarm = Alarm()
            alarm.add("action", "DISPLAY")
            alarm.add("description", f"{session_type} starts soon!")
            alarm.add("trigger", timedelta(minutes=-30))
            ev.add_component(alarm)
            cal.add_component(ev)
        return cal

    # Je≈õli sƒÖ mecze z JSON
    for i, (p1, p2, time_text) in enumerate(matches):
        summary = f"{p1} vs {p2} (Turin)"

        # Pr√≥ba sparsowania czasu meczu, je≈õli podany w formacie HH:MM
        hour, minute = (13, 0)  # domy≈õlnie Day Session
        try:
            if ":" in time_text:
                h, m = map(int, time_text.split(":"))
                hour, minute = h, m
            elif time_text.upper() in ["TBD", ""]:
                hour, minute = (13, 0)
        except:
            hour, minute = (13, 0)

        start_guess = TIMEZONE.localize(datetime(2025, 11, 9 + i // 2, hour, minute))
        end_guess = start_guess + timedelta(hours=2)

        ev = Event()
        ev.add("summary", summary)
        ev.add("description", f"{TOURNAMENT}\nScheduled: {time_text}")
        ev.add("location", LOCATION)
        ev.add("dtstart", vDatetime(start_guess))
        ev.add("dtend", vDatetime(end_guess))
        ev.add("dtstamp", vDatetime(datetime.now(TIMEZONE)))
        ev.add("uid", f"match-{i}@atpfinals2025")

        alarm = Alarm()
        alarm.add("action", "DISPLAY")
        alarm.add("description", f"{summary} starts soon!")
        alarm.add("trigger", timedelta(minutes=-30))
        ev.add_component(alarm)
        cal.add_component(ev)

    return cal


# === G≈Ç√≥wne wykonanie ===
if __name__ == "__main__":
    current_day = get_current_day()
    base_url_html = BASE_URL_TEMPLATE.format(day=current_day)

    print(f"üîÑ Generowanie kalendarza ATP Finals 2025 ({LOCATION}) dla dnia {current_day}")
    matches = get_matches_from_json()
    calendar = create_ics(matches)

    with open(ics_path, "wb") as f:
        f.write(calendar.to_ical())

    print(f"‚úÖ Plik {ics_path} zapisany ({len(matches)} mecz√≥w wczytano).")
